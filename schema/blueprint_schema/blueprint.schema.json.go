// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package blueprint_schema

import "encoding/json"
import "fmt"
import yaml "gopkg.in/yaml.v3"
import "reflect"

// Parameters for arithmetic combinators.
type ArithmeticConditions struct {
	// First input signal.
	FirstSignal *SignalID `json:"first_signal,omitempty" yaml:"first_signal,omitempty" mapstructure:"first_signal,omitempty"`

	// Arithmetic operation (e.g., '+', '-', '*', '/').
	Operation *string `json:"operation,omitempty" yaml:"operation,omitempty" mapstructure:"operation,omitempty"`

	// Signal where the result is stored.
	OutputSignal *SignalID `json:"output_signal,omitempty" yaml:"output_signal,omitempty" mapstructure:"output_signal,omitempty"`

	// Second input signal.
	SecondSignal *SignalID `json:"second_signal,omitempty" yaml:"second_signal,omitempty" mapstructure:"second_signal,omitempty"`
}

// An object representing a Factorio blueprint.
type Blueprint struct {
	// Indicates if absolute snapping is enabled.
	AbsoluteSnapping *bool `json:"absolute-snapping,omitempty" yaml:"absolute-snapping,omitempty" mapstructure:"absolute-snapping,omitempty"`

	// An optional description of the blueprint.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// An array of entities included in the blueprint.
	Entities []Entity `json:"entities" yaml:"entities" mapstructure:"entities"`

	// Icons set by the user for the blueprint.
	Icons []Icon `json:"icons" yaml:"icons" mapstructure:"icons"`

	// The name of the item; usually 'blueprint' in vanilla Factorio.
	Item string `json:"item" yaml:"item" mapstructure:"item"`

	// The user-defined name of the blueprint.
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// The color assigned to the blueprint's label.
	LabelColor *Color `json:"label_color,omitempty" yaml:"label_color,omitempty" mapstructure:"label_color,omitempty"`

	// Offset relative to the global snapping grid.
	PositionRelativeToGrid *Position `json:"position-relative-to-grid,omitempty" yaml:"position-relative-to-grid,omitempty" mapstructure:"position-relative-to-grid,omitempty"`

	// Train schedules included in the blueprint.
	Schedules []Schedule `json:"schedules,omitempty" yaml:"schedules,omitempty" mapstructure:"schedules,omitempty"`

	// Dimensions of the grid used for snapping.
	SnapToGrid *Position `json:"snap-to-grid,omitempty" yaml:"snap-to-grid,omitempty" mapstructure:"snap-to-grid,omitempty"`

	// An array of tiles included in the blueprint.
	Tiles []Tile `json:"tiles,omitempty" yaml:"tiles,omitempty" mapstructure:"tiles,omitempty"`

	// The game version when the blueprint was created.
	Version int `json:"version" yaml:"version" mapstructure:"version"`
}

// An object representing a Factorio blueprint book.
type BlueprintBook struct {
	// Index of the currently selected blueprint, 0-based.
	ActiveIndex *int `json:"active_index,omitempty" yaml:"active_index,omitempty" mapstructure:"active_index,omitempty"`

	// The content of the blueprint book.
	Blueprints []BlueprintBookBlueprintsElem `json:"blueprints" yaml:"blueprints" mapstructure:"blueprints"`

	// An optional description of the blueprint book.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Icons set by the user for the blueprint book.
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// The name of the item; usually 'blueprint-book' in vanilla Factorio.
	Item BlueprintBookItem `json:"item" yaml:"item" mapstructure:"item"`

	// The user-defined name of the blueprint book.
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// The color assigned to the blueprint book's label.
	LabelColor *Color `json:"label_color,omitempty" yaml:"label_color,omitempty" mapstructure:"label_color,omitempty"`

	// The game version when the blueprint book was created.
	Version int `json:"version" yaml:"version" mapstructure:"version"`
}

// An array containing the blueprints included in the book.
type BlueprintBookBlueprintsElem struct {
	// A blueprint object.
	Blueprint Blueprint `json:"blueprint" yaml:"blueprint" mapstructure:"blueprint"`

	// Index of the blueprint in the book, 0-based.
	Index int `json:"index" yaml:"index" mapstructure:"index"`
}

type BlueprintBookItem string

const BlueprintBookItemBlueprintBook BlueprintBookItem = "blueprint-book"

type BlueprintSchemaJSON struct {
	// Blueprint corresponds to the JSON schema field "blueprint".
	Blueprint *Blueprint `json:"blueprint,omitempty" yaml:"blueprint,omitempty" mapstructure:"blueprint,omitempty"`

	// BlueprintBook corresponds to the JSON schema field "blueprint-book".
	BlueprintBook *BlueprintBook `json:"blueprint-book,omitempty" yaml:"blueprint-book,omitempty" mapstructure:"blueprint-book,omitempty"`
}

// A color with RGBA components.
type Color struct {
	// Alpha (transparency) component (0 to 1).
	A *float64 `json:"a,omitempty" yaml:"a,omitempty" mapstructure:"a,omitempty"`

	// Blue component (0 to 1).
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// Green component (0 to 1).
	G float64 `json:"g" yaml:"g" mapstructure:"g"`

	// Red component (0 to 1).
	R float64 `json:"r" yaml:"r" mapstructure:"r"`
}

// A circuit or logistic condition.
type Condition struct {
	// Comparator operator (e.g., '>', '=', '<').
	Comparator *string `json:"comparator,omitempty" yaml:"comparator,omitempty" mapstructure:"comparator,omitempty"`

	// A constant value used in the condition.
	Constant *int `json:"constant,omitempty" yaml:"constant,omitempty" mapstructure:"constant,omitempty"`

	// The first signal in the condition.
	FirstSignal *SignalID `json:"first_signal,omitempty" yaml:"first_signal,omitempty" mapstructure:"first_signal,omitempty"`

	// The second signal in the condition.
	SecondSignal *SignalID `json:"second_signal,omitempty" yaml:"second_signal,omitempty" mapstructure:"second_signal,omitempty"`
}

// Circuit network connections for an entity.
type Connection struct {
	// First connection point.
	A1 *ConnectionPoint `json:"1,omitempty" yaml:"1,omitempty" mapstructure:"1,omitempty"`

	// Second connection point (if applicable).
	A2 *ConnectionPoint `json:"2,omitempty" yaml:"2,omitempty" mapstructure:"2,omitempty"`
}

// Information about a single circuit network connection.
type ConnectionData struct {
	// Circuit connector ID of the connected entity.
	CircuitID *int `json:"circuit_id,omitempty" yaml:"circuit_id,omitempty" mapstructure:"circuit_id,omitempty"`

	// Entity number of the connected entity.
	EntityID int `json:"entity_id" yaml:"entity_id" mapstructure:"entity_id"`
}

// A connection point for circuit network wires.
type ConnectionPoint struct {
	// Connections made with green wires.
	Green []ConnectionData `json:"green,omitempty" yaml:"green,omitempty" mapstructure:"green,omitempty"`

	// Connections made with red wires.
	Red []ConnectionData `json:"red,omitempty" yaml:"red,omitempty" mapstructure:"red,omitempty"`
}

// Control behavior settings for entities.
type ControlBehavior struct {
	// Settings for arithmetic combinators.
	ArithmeticConditions *ArithmeticConditions `json:"arithmetic_conditions,omitempty" yaml:"arithmetic_conditions,omitempty" mapstructure:"arithmetic_conditions,omitempty"`

	// Condition for circuit network signals.
	CircuitCondition *Condition `json:"circuit_condition,omitempty" yaml:"circuit_condition,omitempty" mapstructure:"circuit_condition,omitempty"`

	// Settings for decider combinators.
	DeciderConditions *DeciderConditions `json:"decider_conditions,omitempty" yaml:"decider_conditions,omitempty" mapstructure:"decider_conditions,omitempty"`

	// Filters used by constant combinators and other entities.
	Filters []ItemFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`

	// Indicates if the entity is active.
	IsOn *bool `json:"is_on,omitempty" yaml:"is_on,omitempty" mapstructure:"is_on,omitempty"`

	// Condition for logistic network signals.
	LogisticCondition *Condition `json:"logistic_condition,omitempty" yaml:"logistic_condition,omitempty" mapstructure:"logistic_condition,omitempty"`
}

// Parameters for decider combinators.
type DeciderConditions struct {
	// Comparator operator.
	Comparator *string `json:"comparator,omitempty" yaml:"comparator,omitempty" mapstructure:"comparator,omitempty"`

	// Constant value for comparison.
	Constant *int `json:"constant,omitempty" yaml:"constant,omitempty" mapstructure:"constant,omitempty"`

	// Whether to copy the input count to the output.
	CopyCountFromInput *bool `json:"copy_count_from_input,omitempty" yaml:"copy_count_from_input,omitempty" mapstructure:"copy_count_from_input,omitempty"`

	// First input signal.
	FirstSignal *SignalID `json:"first_signal,omitempty" yaml:"first_signal,omitempty" mapstructure:"first_signal,omitempty"`

	// Signal to output when condition is true.
	OutputSignal *SignalID `json:"output_signal,omitempty" yaml:"output_signal,omitempty" mapstructure:"output_signal,omitempty"`

	// Second input signal.
	SecondSignal *SignalID `json:"second_signal,omitempty" yaml:"second_signal,omitempty" mapstructure:"second_signal,omitempty"`
}

// An entity placed within the blueprint.
type Entity struct {
	// Used by Programmable Speaker (optional).
	AlertParameters *SpeakerAlertParameters `json:"alert_parameters,omitempty" yaml:"alert_parameters,omitempty" mapstructure:"alert_parameters,omitempty"`

	// Ammo inventory of an entity (e.g., Spidertron) (optional).
	AmmoInventory *Inventory `json:"ammo_inventory,omitempty" yaml:"ammo_inventory,omitempty" mapstructure:"ammo_inventory,omitempty"`

	// Used by the rocket silo; whether auto launch is enabled (optional).
	AutoLaunch *bool `json:"auto_launch,omitempty" yaml:"auto_launch,omitempty" mapstructure:"auto_launch,omitempty"`

	// Index of the first inaccessible item slot due to limiting with the red "bar"
	// (optional).
	Bar *int `json:"bar,omitempty" yaml:"bar,omitempty" mapstructure:"bar,omitempty"`

	// Color of the entity (optional).
	Color *Color `json:"color,omitempty" yaml:"color,omitempty" mapstructure:"color,omitempty"`

	// Circuit connections (optional).
	Connections *Connection `json:"connections,omitempty" yaml:"connections,omitempty" mapstructure:"connections,omitempty"`

	// Control behavior of this entity (optional).
	ControlBehavior *ControlBehavior `json:"control_behavior,omitempty" yaml:"control_behavior,omitempty" mapstructure:"control_behavior,omitempty"`

	// Direction of the entity, uint (optional).
	Direction *int `json:"direction,omitempty" yaml:"direction,omitempty" mapstructure:"direction,omitempty"`

	// Drop position the inserter is set to (optional).
	DropPosition *Position `json:"drop_position,omitempty" yaml:"drop_position,omitempty" mapstructure:"drop_position,omitempty"`

	// Index of the entity, 1-based.
	EntityNumber int `json:"entity_number" yaml:"entity_number" mapstructure:"entity_number"`

	// Filter of the splitter; name of the item prototype (optional).
	Filter *string `json:"filter,omitempty" yaml:"filter,omitempty" mapstructure:"filter,omitempty"`

	// Filter mode of the filter inserter (optional).
	FilterMode *EntityFilterMode `json:"filter_mode,omitempty" yaml:"filter_mode,omitempty" mapstructure:"filter_mode,omitempty"`

	// Filters of the filter inserter or loader (optional).
	Filters []ItemFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`

	// Used by InfinityContainer (optional).
	InfinitySettings *InfinitySettings `json:"infinity_settings,omitempty" yaml:"infinity_settings,omitempty" mapstructure:"infinity_settings,omitempty"`

	// Input priority of the splitter (optional).
	InputPriority *EntityInputPriority `json:"input_priority,omitempty" yaml:"input_priority,omitempty" mapstructure:"input_priority,omitempty"`

	// Cargo wagon inventory configuration (optional).
	Inventory *Inventory `json:"inventory,omitempty" yaml:"inventory,omitempty" mapstructure:"inventory,omitempty"`

	// Item requests by this entity (optional).
	Items ItemRequest `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Manually set train limit of the train station (optional).
	ManualTrainsLimit *int `json:"manual_trains_limit,omitempty" yaml:"manual_trains_limit,omitempty" mapstructure:"manual_trains_limit,omitempty"`

	// Prototype name of the entity (e.g., "offshore-pump").
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Copper wire connections, array of entity_numbers (optional).
	Neighbours []int `json:"neighbours,omitempty" yaml:"neighbours,omitempty" mapstructure:"neighbours,omitempty"`

	// Orientation of cargo wagon or locomotive, value 0 to 1 (optional).
	Orientation *float64 `json:"orientation,omitempty" yaml:"orientation,omitempty" mapstructure:"orientation,omitempty"`

	// Output priority of the splitter (optional).
	OutputPriority *EntityOutputPriority `json:"output_priority,omitempty" yaml:"output_priority,omitempty" mapstructure:"output_priority,omitempty"`

	// Stack size the inserter is set to (optional).
	OverrideStackSize *int `json:"override_stack_size,omitempty" yaml:"override_stack_size,omitempty" mapstructure:"override_stack_size,omitempty"`

	// Used by Programmable Speaker (optional).
	Parameters *SpeakerParameters `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Pickup position the inserter is set to (optional).
	PickupPosition *Position `json:"pickup_position,omitempty" yaml:"pickup_position,omitempty" mapstructure:"pickup_position,omitempty"`

	// Position of the entity within the blueprint.
	Position Position `json:"position" yaml:"position" mapstructure:"position"`

	// Name of the recipe prototype this assembling machine is set to (optional).
	Recipe *string `json:"recipe,omitempty" yaml:"recipe,omitempty" mapstructure:"recipe,omitempty"`

	// Used by LogisticContainer; array of logistic filters (optional).
	RequestFilters []LogisticFilter `json:"request_filters,omitempty" yaml:"request_filters,omitempty" mapstructure:"request_filters,omitempty"`

	// Whether the requester chest can request from buffer chests (optional).
	RequestFromBuffers *bool `json:"request_from_buffers,omitempty" yaml:"request_from_buffers,omitempty" mapstructure:"request_from_buffers,omitempty"`

	// Name of the train station (optional).
	Station *string `json:"station,omitempty" yaml:"station,omitempty" mapstructure:"station,omitempty"`

	// Current state of the power switch (optional).
	SwitchState *bool `json:"switch_state,omitempty" yaml:"switch_state,omitempty" mapstructure:"switch_state,omitempty"`

	// Dictionary of arbitrary data (optional).
	Tags EntityTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Boot/Luggage inventory of an entity (e.g., storage inventory of a Spidertron)
	// (optional).
	TrunkInventory *Inventory `json:"trunk_inventory,omitempty" yaml:"trunk_inventory,omitempty" mapstructure:"trunk_inventory,omitempty"`

	// Type of the underground belt or loader (optional).
	Type *EntityType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Used by SimpleEntityWithForce or SimpleEntityWithOwner (optional).
	Variation *int `json:"variation,omitempty" yaml:"variation,omitempty" mapstructure:"variation,omitempty"`
}

type EntityFilterMode string

const EntityFilterModeBlacklist EntityFilterMode = "blacklist"
const EntityFilterModeWhitelist EntityFilterMode = "whitelist"

type EntityInputPriority string

const EntityInputPriorityLeft EntityInputPriority = "left"
const EntityInputPriorityRight EntityInputPriority = "right"

type EntityOutputPriority string

const EntityOutputPriorityLeft EntityOutputPriority = "left"
const EntityOutputPriorityRight EntityOutputPriority = "right"

// Dictionary of arbitrary data (optional).
type EntityTags map[string]interface{}

type EntityType string

const EntityTypeInput EntityType = "input"
const EntityTypeOutput EntityType = "output"

// An icon representing an item, fluid, or virtual signal.
type Icon struct {
	// The 1-based index of the icon.
	Index int `json:"index" yaml:"index" mapstructure:"index"`

	// The signal used as the icon.
	Signal SignalID `json:"signal" yaml:"signal" mapstructure:"signal"`
}

// A filter for Infinity container items.
type InfinityFilter struct {
	// Desired item count.
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// 1-based index of the filter.
	Index *int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// Mode defining how item count is maintained.
	Mode *InfinityFilterMode `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Name of the item prototype.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

type InfinityFilterMode string

const InfinityFilterModeAtLeast InfinityFilterMode = "at-least"
const InfinityFilterModeAtMost InfinityFilterMode = "at-most"
const InfinityFilterModeExactly InfinityFilterMode = "exactly"

// Settings for Infinity containers.
type InfinitySettings struct {
	// Filters specifying item settings.
	Filters []InfinityFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`

	// Whether to remove items not specified in the filters.
	RemoveUnfilteredItems *bool `json:"remove_unfiltered_items,omitempty" yaml:"remove_unfiltered_items,omitempty" mapstructure:"remove_unfiltered_items,omitempty"`
}

// Configuration of an entity's inventory.
type Inventory struct {
	// Index of the first inaccessible slot due to the red 'bar'.
	Bar *int `json:"bar,omitempty" yaml:"bar,omitempty" mapstructure:"bar,omitempty"`

	// Array of item filters.
	Filters []ItemFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`
}

// Filter settings for items in an inventory.
type ItemFilter struct {
	// 1-based index of the filter slot.
	Index int `json:"index" yaml:"index" mapstructure:"index"`

	// Name of the item prototype.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// Item requests by the entity for construction.
type ItemRequest map[string]int

// Filter settings for logistic containers.
type LogisticFilter struct {
	// Requested item count (0 for storage chests).
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// 1-based index of the filter slot.
	Index *int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// Name of the item prototype.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Entity) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["entity_number"]; !ok || v == nil {
		return fmt.Errorf("field entity_number in Entity: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Entity: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Entity: required")
	}
	type Plain Entity
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Entity(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InfinityFilterMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InfinityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InfinityFilterMode, v)
	}
	*j = InfinityFilterMode(v)
	return nil
}

var enumValues_InfinityFilterMode = []interface{}{
	"at-least",
	"at-most",
	"exactly",
}

// Alert settings for a programmable speaker.
type SpeakerAlertParameters struct {
	// Custom message for the alert.
	AlertMessage *string `json:"alert_message,omitempty" yaml:"alert_message,omitempty" mapstructure:"alert_message,omitempty"`

	// Icon displayed with the alert.
	IconSignalID *SignalID `json:"icon_signal_id,omitempty" yaml:"icon_signal_id,omitempty" mapstructure:"icon_signal_id,omitempty"`

	// Whether to show an alert.
	ShowAlert *bool `json:"show_alert,omitempty" yaml:"show_alert,omitempty" mapstructure:"show_alert,omitempty"`

	// Whether to show the alert on the map.
	ShowOnMap *bool `json:"show_on_map,omitempty" yaml:"show_on_map,omitempty" mapstructure:"show_on_map,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityFilterMode) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityFilterMode, v)
	}
	*j = EntityFilterMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityFilterMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityFilterMode, v)
	}
	*j = EntityFilterMode(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *SignalID) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SignalID: required")
	}
	type Plain SignalID
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = SignalID(plain)
	return nil
}

var enumValues_EntityInputPriority = []interface{}{
	"right",
	"left",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityInputPriority) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityInputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityInputPriority, v)
	}
	*j = EntityInputPriority(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityInputPriority) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityInputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityInputPriority, v)
	}
	*j = EntityInputPriority(v)
	return nil
}

type SignalIDType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignalID) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SignalID: required")
	}
	type Plain SignalID
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SignalID(plain)
	return nil
}

var enumValues_EntityFilterMode = []interface{}{
	"whitelist",
	"blacklist",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ItemFilter) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in ItemFilter: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ItemFilter: required")
	}
	type Plain ItemFilter
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ItemFilter(plain)
	return nil
}

var enumValues_EntityOutputPriority = []interface{}{
	"right",
	"left",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityOutputPriority) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityOutputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityOutputPriority, v)
	}
	*j = EntityOutputPriority(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityOutputPriority) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityOutputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityOutputPriority, v)
	}
	*j = EntityOutputPriority(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Position) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["x"]; !ok || v == nil {
		return fmt.Errorf("field x in Position: required")
	}
	if v, ok := raw["y"]; !ok || v == nil {
		return fmt.Errorf("field y in Position: required")
	}
	type Plain Position
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Position(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Position) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["x"]; !ok || v == nil {
		return fmt.Errorf("field x in Position: required")
	}
	if v, ok := raw["y"]; !ok || v == nil {
		return fmt.Errorf("field y in Position: required")
	}
	type Plain Position
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Position(plain)
	return nil
}

// Playback settings for a programmable speaker.
type SpeakerParameters struct {
	// Whether multiple sounds can play simultaneously.
	AllowPolyphony *bool `json:"allow_polyphony,omitempty" yaml:"allow_polyphony,omitempty" mapstructure:"allow_polyphony,omitempty"`

	// Whether the sound plays globally.
	PlaybackGlobally *bool `json:"playback_globally,omitempty" yaml:"playback_globally,omitempty" mapstructure:"playback_globally,omitempty"`

	// Volume of the speaker.
	PlaybackVolume *float64 `json:"playback_volume,omitempty" yaml:"playback_volume,omitempty" mapstructure:"playback_volume,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *ConnectionData) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["entity_id"]; !ok || v == nil {
		return fmt.Errorf("field entity_id in ConnectionData: required")
	}
	type Plain ConnectionData
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = ConnectionData(plain)
	return nil
}

// A position in 2D space.
type Position struct {
	// The x-coordinate.
	X float64 `json:"x" yaml:"x" mapstructure:"x"`

	// The y-coordinate.
	Y float64 `json:"y" yaml:"y" mapstructure:"y"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *ItemFilter) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in ItemFilter: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ItemFilter: required")
	}
	type Plain ItemFilter
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = ItemFilter(plain)
	return nil
}

var enumValues_EntityType = []interface{}{
	"input",
	"output",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityType, v)
	}
	*j = EntityType(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityType, v)
	}
	*j = EntityType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Color) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["b"]; !ok || v == nil {
		return fmt.Errorf("field b in Color: required")
	}
	if v, ok := raw["g"]; !ok || v == nil {
		return fmt.Errorf("field g in Color: required")
	}
	if v, ok := raw["r"]; !ok || v == nil {
		return fmt.Errorf("field r in Color: required")
	}
	type Plain Color
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Color(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Color) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["b"]; !ok || v == nil {
		return fmt.Errorf("field b in Color: required")
	}
	if v, ok := raw["g"]; !ok || v == nil {
		return fmt.Errorf("field g in Color: required")
	}
	if v, ok := raw["r"]; !ok || v == nil {
		return fmt.Errorf("field r in Color: required")
	}
	type Plain Color
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Color(plain)
	return nil
}

// An identifier for a signal in the game.
type SignalID struct {
	// The name of the signal.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The type of the signal.
	Type *SignalIDType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Entity) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["entity_number"]; !ok || v == nil {
		return fmt.Errorf("field entity_number in Entity: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Entity: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Entity: required")
	}
	type Plain Entity
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Entity(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *InfinityFilterMode) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InfinityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InfinityFilterMode, v)
	}
	*j = InfinityFilterMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectionData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["entity_id"]; !ok || v == nil {
		return fmt.Errorf("field entity_id in ConnectionData: required")
	}
	type Plain ConnectionData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConnectionData(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Icon) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in Icon: required")
	}
	if v, ok := raw["signal"]; !ok || v == nil {
		return fmt.Errorf("field signal in Icon: required")
	}
	type Plain Icon
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Icon(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Icon) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in Icon: required")
	}
	if v, ok := raw["signal"]; !ok || v == nil {
		return fmt.Errorf("field signal in Icon: required")
	}
	type Plain Icon
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Icon(plain)
	return nil
}

type WaitConditionCompareType string

var enumValues_WaitConditionCompareType = []interface{}{
	"and",
	"or",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WaitConditionCompareType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WaitConditionCompareType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WaitConditionCompareType, v)
	}
	*j = WaitConditionCompareType(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *WaitConditionCompareType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WaitConditionCompareType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WaitConditionCompareType, v)
	}
	*j = WaitConditionCompareType(v)
	return nil
}

const WaitConditionCompareTypeAnd WaitConditionCompareType = "and"
const WaitConditionCompareTypeOr WaitConditionCompareType = "or"

// A condition defining how long a train waits at a station.
type WaitCondition struct {
	// Logical operator for combining conditions.
	CompareType *WaitConditionCompareType `json:"compare_type,omitempty" yaml:"compare_type,omitempty" mapstructure:"compare_type,omitempty"`

	// Number of ticks to wait (used with 'time' or 'inactivity' types).
	Ticks *int `json:"ticks,omitempty" yaml:"ticks,omitempty" mapstructure:"ticks,omitempty"`

	// Type of the wait condition.
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// A single record in a train schedule.
type ScheduleRecord struct {
	// Name of the train stop.
	Station *string `json:"station,omitempty" yaml:"station,omitempty" mapstructure:"station,omitempty"`

	// Conditions under which the train waits at this stop.
	WaitConditions []WaitCondition `json:"wait_conditions,omitempty" yaml:"wait_conditions,omitempty" mapstructure:"wait_conditions,omitempty"`
}

// Train schedule data.
type Schedule struct {
	// Entity numbers of locomotives using this schedule.
	Locomotives []int `json:"locomotives,omitempty" yaml:"locomotives,omitempty" mapstructure:"locomotives,omitempty"`

	// Array of schedule records.
	Schedule []ScheduleRecord `json:"schedule,omitempty" yaml:"schedule,omitempty" mapstructure:"schedule,omitempty"`
}

// A tile placed within the blueprint.
type Tile struct {
	// The prototype name of the tile.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The position of the tile on the blueprint grid.
	Position Position `json:"position" yaml:"position" mapstructure:"position"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Tile: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Tile: required")
	}
	type Plain Tile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Tile(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Tile) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Tile: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Tile: required")
	}
	type Plain Tile
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Tile(plain)
	return nil
}

const SignalIDTypeVirtual SignalIDType = "virtual"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Blueprint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["entities"]; !ok || v == nil {
		return fmt.Errorf("field entities in Blueprint: required")
	}
	if v, ok := raw["icons"]; !ok || v == nil {
		return fmt.Errorf("field icons in Blueprint: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in Blueprint: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in Blueprint: required")
	}
	type Plain Blueprint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Blueprint(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Blueprint) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["entities"]; !ok || v == nil {
		return fmt.Errorf("field entities in Blueprint: required")
	}
	if v, ok := raw["icons"]; !ok || v == nil {
		return fmt.Errorf("field icons in Blueprint: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in Blueprint: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in Blueprint: required")
	}
	type Plain Blueprint
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Blueprint(plain)
	return nil
}

const SignalIDTypeFluid SignalIDType = "fluid"

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlueprintBookBlueprintsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blueprint"]; !ok || v == nil {
		return fmt.Errorf("field blueprint in BlueprintBookBlueprintsElem: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in BlueprintBookBlueprintsElem: required")
	}
	type Plain BlueprintBookBlueprintsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BlueprintBookBlueprintsElem(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BlueprintBookBlueprintsElem) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["blueprint"]; !ok || v == nil {
		return fmt.Errorf("field blueprint in BlueprintBookBlueprintsElem: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in BlueprintBookBlueprintsElem: required")
	}
	type Plain BlueprintBookBlueprintsElem
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = BlueprintBookBlueprintsElem(plain)
	return nil
}

const SignalIDTypeItem SignalIDType = "item"

var enumValues_BlueprintBookItem = []interface{}{
	"blueprint-book",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlueprintBookItem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlueprintBookItem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlueprintBookItem, v)
	}
	*j = BlueprintBookItem(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BlueprintBookItem) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlueprintBookItem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlueprintBookItem, v)
	}
	*j = BlueprintBookItem(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *SignalIDType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SignalIDType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SignalIDType, v)
	}
	*j = SignalIDType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignalIDType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SignalIDType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SignalIDType, v)
	}
	*j = SignalIDType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlueprintBook) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blueprints"]; !ok || v == nil {
		return fmt.Errorf("field blueprints in BlueprintBook: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in BlueprintBook: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in BlueprintBook: required")
	}
	type Plain BlueprintBook
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BlueprintBook(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BlueprintBook) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["blueprints"]; !ok || v == nil {
		return fmt.Errorf("field blueprints in BlueprintBook: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in BlueprintBook: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in BlueprintBook: required")
	}
	type Plain BlueprintBook
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = BlueprintBook(plain)
	return nil
}

var enumValues_SignalIDType = []interface{}{
	"item",
	"fluid",
	"virtual",
}
