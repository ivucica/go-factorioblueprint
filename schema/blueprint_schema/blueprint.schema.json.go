// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package blueprint_schema

import "encoding/json"
import "fmt"
import yaml "gopkg.in/yaml.v3"
import "reflect"

type ArithmeticConditions struct {
	// FirstSignal corresponds to the JSON schema field "first_signal".
	FirstSignal *SignalID `json:"first_signal,omitempty" yaml:"first_signal,omitempty" mapstructure:"first_signal,omitempty"`

	// Operation corresponds to the JSON schema field "operation".
	Operation *string `json:"operation,omitempty" yaml:"operation,omitempty" mapstructure:"operation,omitempty"`

	// OutputSignal corresponds to the JSON schema field "output_signal".
	OutputSignal *SignalID `json:"output_signal,omitempty" yaml:"output_signal,omitempty" mapstructure:"output_signal,omitempty"`

	// SecondSignal corresponds to the JSON schema field "second_signal".
	SecondSignal *SignalID `json:"second_signal,omitempty" yaml:"second_signal,omitempty" mapstructure:"second_signal,omitempty"`
}

type Blueprint struct {
	// AbsoluteSnapping corresponds to the JSON schema field "absolute-snapping".
	AbsoluteSnapping *bool `json:"absolute-snapping,omitempty" yaml:"absolute-snapping,omitempty" mapstructure:"absolute-snapping,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Entities corresponds to the JSON schema field "entities".
	Entities []Entity `json:"entities" yaml:"entities" mapstructure:"entities"`

	// Icons corresponds to the JSON schema field "icons".
	Icons []Icon `json:"icons" yaml:"icons" mapstructure:"icons"`

	// Item corresponds to the JSON schema field "item".
	Item BlueprintItem `json:"item" yaml:"item" mapstructure:"item"`

	// Label corresponds to the JSON schema field "label".
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// LabelColor corresponds to the JSON schema field "label_color".
	LabelColor *Color `json:"label_color,omitempty" yaml:"label_color,omitempty" mapstructure:"label_color,omitempty"`

	// PositionRelativeToGrid corresponds to the JSON schema field
	// "position-relative-to-grid".
	PositionRelativeToGrid *Position `json:"position-relative-to-grid,omitempty" yaml:"position-relative-to-grid,omitempty" mapstructure:"position-relative-to-grid,omitempty"`

	// Schedules corresponds to the JSON schema field "schedules".
	Schedules []Schedule `json:"schedules,omitempty" yaml:"schedules,omitempty" mapstructure:"schedules,omitempty"`

	// SnapToGrid corresponds to the JSON schema field "snap-to-grid".
	SnapToGrid *Position `json:"snap-to-grid,omitempty" yaml:"snap-to-grid,omitempty" mapstructure:"snap-to-grid,omitempty"`

	// Tiles corresponds to the JSON schema field "tiles".
	Tiles []Tile `json:"tiles,omitempty" yaml:"tiles,omitempty" mapstructure:"tiles,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version int `json:"version" yaml:"version" mapstructure:"version"`
}

type BlueprintItem string

const BlueprintItemBlueprint BlueprintItem = "blueprint"

type BlueprintSchemaJSON struct {
	// Blueprint corresponds to the JSON schema field "blueprint".
	Blueprint *Blueprint `json:"blueprint,omitempty" yaml:"blueprint,omitempty" mapstructure:"blueprint,omitempty"`

	// BlueprintBook corresponds to the JSON schema field "blueprint-book".
	BlueprintBook *BlueprintSchemaJSONBlueprintBook `json:"blueprint-book,omitempty" yaml:"blueprint-book,omitempty" mapstructure:"blueprint-book,omitempty"`
}

type BlueprintSchemaJSONBlueprintBook struct {
	// ActiveIndex corresponds to the JSON schema field "active_index".
	ActiveIndex *int `json:"active_index,omitempty" yaml:"active_index,omitempty" mapstructure:"active_index,omitempty"`

	// Blueprints corresponds to the JSON schema field "blueprints".
	Blueprints []BlueprintSchemaJSONBlueprintBookBlueprintsElem `json:"blueprints" yaml:"blueprints" mapstructure:"blueprints"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Icons corresponds to the JSON schema field "icons".
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// Item corresponds to the JSON schema field "item".
	Item BlueprintSchemaJSONBlueprintBookItem `json:"item" yaml:"item" mapstructure:"item"`

	// Label corresponds to the JSON schema field "label".
	Label *string `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// LabelColor corresponds to the JSON schema field "label_color".
	LabelColor *Color `json:"label_color,omitempty" yaml:"label_color,omitempty" mapstructure:"label_color,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version int `json:"version" yaml:"version" mapstructure:"version"`
}

type BlueprintSchemaJSONBlueprintBookBlueprintsElem struct {
	// Blueprint corresponds to the JSON schema field "blueprint".
	Blueprint Blueprint `json:"blueprint" yaml:"blueprint" mapstructure:"blueprint"`

	// Index corresponds to the JSON schema field "index".
	Index int `json:"index" yaml:"index" mapstructure:"index"`
}

type BlueprintSchemaJSONBlueprintBookItem string

const BlueprintSchemaJSONBlueprintBookItemBlueprintBook BlueprintSchemaJSONBlueprintBookItem = "blueprint-book"

type Color struct {
	// A corresponds to the JSON schema field "a".
	A *float64 `json:"a,omitempty" yaml:"a,omitempty" mapstructure:"a,omitempty"`

	// B corresponds to the JSON schema field "b".
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// G corresponds to the JSON schema field "g".
	G float64 `json:"g" yaml:"g" mapstructure:"g"`

	// R corresponds to the JSON schema field "r".
	R float64 `json:"r" yaml:"r" mapstructure:"r"`
}

type Condition struct {
	// Comparator corresponds to the JSON schema field "comparator".
	Comparator *string `json:"comparator,omitempty" yaml:"comparator,omitempty" mapstructure:"comparator,omitempty"`

	// Constant corresponds to the JSON schema field "constant".
	Constant *int `json:"constant,omitempty" yaml:"constant,omitempty" mapstructure:"constant,omitempty"`

	// FirstSignal corresponds to the JSON schema field "first_signal".
	FirstSignal *SignalID `json:"first_signal,omitempty" yaml:"first_signal,omitempty" mapstructure:"first_signal,omitempty"`

	// SecondSignal corresponds to the JSON schema field "second_signal".
	SecondSignal *SignalID `json:"second_signal,omitempty" yaml:"second_signal,omitempty" mapstructure:"second_signal,omitempty"`
}

type Connection struct {
	// A1 corresponds to the JSON schema field "1".
	A1 *ConnectionPoint `json:"1,omitempty" yaml:"1,omitempty" mapstructure:"1,omitempty"`

	// A2 corresponds to the JSON schema field "2".
	A2 *ConnectionPoint `json:"2,omitempty" yaml:"2,omitempty" mapstructure:"2,omitempty"`
}

type ConnectionData struct {
	// CircuitID corresponds to the JSON schema field "circuit_id".
	CircuitID *int `json:"circuit_id,omitempty" yaml:"circuit_id,omitempty" mapstructure:"circuit_id,omitempty"`

	// EntityID corresponds to the JSON schema field "entity_id".
	EntityID int `json:"entity_id" yaml:"entity_id" mapstructure:"entity_id"`
}

type ConnectionPoint struct {
	// Green corresponds to the JSON schema field "green".
	Green []ConnectionData `json:"green,omitempty" yaml:"green,omitempty" mapstructure:"green,omitempty"`

	// Red corresponds to the JSON schema field "red".
	Red []ConnectionData `json:"red,omitempty" yaml:"red,omitempty" mapstructure:"red,omitempty"`
}

type ControlBehavior struct {
	// ArithmeticConditions corresponds to the JSON schema field
	// "arithmetic_conditions".
	ArithmeticConditions *ArithmeticConditions `json:"arithmetic_conditions,omitempty" yaml:"arithmetic_conditions,omitempty" mapstructure:"arithmetic_conditions,omitempty"`

	// CircuitCondition corresponds to the JSON schema field "circuit_condition".
	CircuitCondition *Condition `json:"circuit_condition,omitempty" yaml:"circuit_condition,omitempty" mapstructure:"circuit_condition,omitempty"`

	// DeciderConditions corresponds to the JSON schema field "decider_conditions".
	DeciderConditions *DeciderConditions `json:"decider_conditions,omitempty" yaml:"decider_conditions,omitempty" mapstructure:"decider_conditions,omitempty"`

	// Filters corresponds to the JSON schema field "filters".
	Filters []ItemFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`

	// IsOn corresponds to the JSON schema field "is_on".
	IsOn *bool `json:"is_on,omitempty" yaml:"is_on,omitempty" mapstructure:"is_on,omitempty"`

	// LogisticCondition corresponds to the JSON schema field "logistic_condition".
	LogisticCondition *Condition `json:"logistic_condition,omitempty" yaml:"logistic_condition,omitempty" mapstructure:"logistic_condition,omitempty"`
}

type DeciderConditions struct {
	// Comparator corresponds to the JSON schema field "comparator".
	Comparator *string `json:"comparator,omitempty" yaml:"comparator,omitempty" mapstructure:"comparator,omitempty"`

	// Constant corresponds to the JSON schema field "constant".
	Constant *int `json:"constant,omitempty" yaml:"constant,omitempty" mapstructure:"constant,omitempty"`

	// CopyCountFromInput corresponds to the JSON schema field
	// "copy_count_from_input".
	CopyCountFromInput *bool `json:"copy_count_from_input,omitempty" yaml:"copy_count_from_input,omitempty" mapstructure:"copy_count_from_input,omitempty"`

	// FirstSignal corresponds to the JSON schema field "first_signal".
	FirstSignal *SignalID `json:"first_signal,omitempty" yaml:"first_signal,omitempty" mapstructure:"first_signal,omitempty"`

	// OutputSignal corresponds to the JSON schema field "output_signal".
	OutputSignal *SignalID `json:"output_signal,omitempty" yaml:"output_signal,omitempty" mapstructure:"output_signal,omitempty"`

	// SecondSignal corresponds to the JSON schema field "second_signal".
	SecondSignal *SignalID `json:"second_signal,omitempty" yaml:"second_signal,omitempty" mapstructure:"second_signal,omitempty"`
}

type Entity struct {
	// AlertParameters corresponds to the JSON schema field "alert_parameters".
	AlertParameters *SpeakerAlertParameters `json:"alert_parameters,omitempty" yaml:"alert_parameters,omitempty" mapstructure:"alert_parameters,omitempty"`

	// AmmoInventory corresponds to the JSON schema field "ammo_inventory".
	AmmoInventory *Inventory `json:"ammo_inventory,omitempty" yaml:"ammo_inventory,omitempty" mapstructure:"ammo_inventory,omitempty"`

	// AutoLaunch corresponds to the JSON schema field "auto_launch".
	AutoLaunch *bool `json:"auto_launch,omitempty" yaml:"auto_launch,omitempty" mapstructure:"auto_launch,omitempty"`

	// Bar corresponds to the JSON schema field "bar".
	Bar *int `json:"bar,omitempty" yaml:"bar,omitempty" mapstructure:"bar,omitempty"`

	// Color corresponds to the JSON schema field "color".
	Color *Color `json:"color,omitempty" yaml:"color,omitempty" mapstructure:"color,omitempty"`

	// Connections corresponds to the JSON schema field "connections".
	Connections *Connection `json:"connections,omitempty" yaml:"connections,omitempty" mapstructure:"connections,omitempty"`

	// ControlBehavior corresponds to the JSON schema field "control_behavior".
	ControlBehavior *ControlBehavior `json:"control_behavior,omitempty" yaml:"control_behavior,omitempty" mapstructure:"control_behavior,omitempty"`

	// Direction corresponds to the JSON schema field "direction".
	Direction *int `json:"direction,omitempty" yaml:"direction,omitempty" mapstructure:"direction,omitempty"`

	// DropPosition corresponds to the JSON schema field "drop_position".
	DropPosition *Position `json:"drop_position,omitempty" yaml:"drop_position,omitempty" mapstructure:"drop_position,omitempty"`

	// EntityNumber corresponds to the JSON schema field "entity_number".
	EntityNumber int `json:"entity_number" yaml:"entity_number" mapstructure:"entity_number"`

	// Filter corresponds to the JSON schema field "filter".
	Filter *string `json:"filter,omitempty" yaml:"filter,omitempty" mapstructure:"filter,omitempty"`

	// FilterMode corresponds to the JSON schema field "filter_mode".
	FilterMode *EntityFilterMode `json:"filter_mode,omitempty" yaml:"filter_mode,omitempty" mapstructure:"filter_mode,omitempty"`

	// Filters corresponds to the JSON schema field "filters".
	Filters []ItemFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`

	// InfinitySettings corresponds to the JSON schema field "infinity_settings".
	InfinitySettings *InfinitySettings `json:"infinity_settings,omitempty" yaml:"infinity_settings,omitempty" mapstructure:"infinity_settings,omitempty"`

	// InputPriority corresponds to the JSON schema field "input_priority".
	InputPriority *EntityInputPriority `json:"input_priority,omitempty" yaml:"input_priority,omitempty" mapstructure:"input_priority,omitempty"`

	// Inventory corresponds to the JSON schema field "inventory".
	Inventory *Inventory `json:"inventory,omitempty" yaml:"inventory,omitempty" mapstructure:"inventory,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items ItemRequest `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// ManualTrainsLimit corresponds to the JSON schema field "manual_trains_limit".
	ManualTrainsLimit *int `json:"manual_trains_limit,omitempty" yaml:"manual_trains_limit,omitempty" mapstructure:"manual_trains_limit,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Neighbours corresponds to the JSON schema field "neighbours".
	Neighbours []int `json:"neighbours,omitempty" yaml:"neighbours,omitempty" mapstructure:"neighbours,omitempty"`

	// Orientation corresponds to the JSON schema field "orientation".
	Orientation *float64 `json:"orientation,omitempty" yaml:"orientation,omitempty" mapstructure:"orientation,omitempty"`

	// OutputPriority corresponds to the JSON schema field "output_priority".
	OutputPriority *EntityOutputPriority `json:"output_priority,omitempty" yaml:"output_priority,omitempty" mapstructure:"output_priority,omitempty"`

	// OverrideStackSize corresponds to the JSON schema field "override_stack_size".
	OverrideStackSize *int `json:"override_stack_size,omitempty" yaml:"override_stack_size,omitempty" mapstructure:"override_stack_size,omitempty"`

	// Parameters corresponds to the JSON schema field "parameters".
	Parameters *SpeakerParameters `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// PickupPosition corresponds to the JSON schema field "pickup_position".
	PickupPosition *Position `json:"pickup_position,omitempty" yaml:"pickup_position,omitempty" mapstructure:"pickup_position,omitempty"`

	// Position corresponds to the JSON schema field "position".
	Position Position `json:"position" yaml:"position" mapstructure:"position"`

	// Recipe corresponds to the JSON schema field "recipe".
	Recipe *string `json:"recipe,omitempty" yaml:"recipe,omitempty" mapstructure:"recipe,omitempty"`

	// RequestFilters corresponds to the JSON schema field "request_filters".
	RequestFilters []LogisticFilter `json:"request_filters,omitempty" yaml:"request_filters,omitempty" mapstructure:"request_filters,omitempty"`

	// RequestFromBuffers corresponds to the JSON schema field "request_from_buffers".
	RequestFromBuffers *bool `json:"request_from_buffers,omitempty" yaml:"request_from_buffers,omitempty" mapstructure:"request_from_buffers,omitempty"`

	// Station corresponds to the JSON schema field "station".
	Station *string `json:"station,omitempty" yaml:"station,omitempty" mapstructure:"station,omitempty"`

	// SwitchState corresponds to the JSON schema field "switch_state".
	SwitchState *bool `json:"switch_state,omitempty" yaml:"switch_state,omitempty" mapstructure:"switch_state,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags EntityTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// TrunkInventory corresponds to the JSON schema field "trunk_inventory".
	TrunkInventory *Inventory `json:"trunk_inventory,omitempty" yaml:"trunk_inventory,omitempty" mapstructure:"trunk_inventory,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *EntityType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Variation corresponds to the JSON schema field "variation".
	Variation *int `json:"variation,omitempty" yaml:"variation,omitempty" mapstructure:"variation,omitempty"`
}

type EntityFilterMode string

const EntityFilterModeBlacklist EntityFilterMode = "blacklist"
const EntityFilterModeWhitelist EntityFilterMode = "whitelist"

type EntityInputPriority string

const EntityInputPriorityLeft EntityInputPriority = "left"
const EntityInputPriorityRight EntityInputPriority = "right"

type EntityOutputPriority string

const EntityOutputPriorityLeft EntityOutputPriority = "left"
const EntityOutputPriorityRight EntityOutputPriority = "right"

type EntityTags map[string]interface{}

type EntityType string

const EntityTypeInput EntityType = "input"
const EntityTypeOutput EntityType = "output"

type Icon struct {
	// Index corresponds to the JSON schema field "index".
	Index int `json:"index" yaml:"index" mapstructure:"index"`

	// Signal corresponds to the JSON schema field "signal".
	Signal SignalID `json:"signal" yaml:"signal" mapstructure:"signal"`
}

type InfinityFilter struct {
	// Count corresponds to the JSON schema field "count".
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Index corresponds to the JSON schema field "index".
	Index *int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *InfinityFilterMode `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

type InfinityFilterMode string

const InfinityFilterModeAtLeast InfinityFilterMode = "at-least"
const InfinityFilterModeAtMost InfinityFilterMode = "at-most"
const InfinityFilterModeExactly InfinityFilterMode = "exactly"

type InfinitySettings struct {
	// Filters corresponds to the JSON schema field "filters".
	Filters []InfinityFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`

	// RemoveUnfilteredItems corresponds to the JSON schema field
	// "remove_unfiltered_items".
	RemoveUnfilteredItems *bool `json:"remove_unfiltered_items,omitempty" yaml:"remove_unfiltered_items,omitempty" mapstructure:"remove_unfiltered_items,omitempty"`
}

type Inventory struct {
	// Bar corresponds to the JSON schema field "bar".
	Bar *int `json:"bar,omitempty" yaml:"bar,omitempty" mapstructure:"bar,omitempty"`

	// Filters corresponds to the JSON schema field "filters".
	Filters []ItemFilter `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`
}

type ItemFilter struct {
	// Index corresponds to the JSON schema field "index".
	Index int `json:"index" yaml:"index" mapstructure:"index"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type ItemRequest map[string]int

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Icon) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in Icon: required")
	}
	if v, ok := raw["signal"]; !ok || v == nil {
		return fmt.Errorf("field signal in Icon: required")
	}
	type Plain Icon
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Icon(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InfinityFilterMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InfinityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InfinityFilterMode, v)
	}
	*j = InfinityFilterMode(v)
	return nil
}

var enumValues_InfinityFilterMode = []interface{}{
	"at-least",
	"at-most",
	"exactly",
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityFilterMode) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityFilterMode, v)
	}
	*j = EntityFilterMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityFilterMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityFilterMode, v)
	}
	*j = EntityFilterMode(v)
	return nil
}

var enumValues_EntityFilterMode = []interface{}{
	"whitelist",
	"blacklist",
}
var enumValues_EntityInputPriority = []interface{}{
	"right",
	"left",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityInputPriority) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityInputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityInputPriority, v)
	}
	*j = EntityInputPriority(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityInputPriority) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityInputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityInputPriority, v)
	}
	*j = EntityInputPriority(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Position) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["x"]; !ok || v == nil {
		return fmt.Errorf("field x in Position: required")
	}
	if v, ok := raw["y"]; !ok || v == nil {
		return fmt.Errorf("field y in Position: required")
	}
	type Plain Position
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Position(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Position) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["x"]; !ok || v == nil {
		return fmt.Errorf("field x in Position: required")
	}
	if v, ok := raw["y"]; !ok || v == nil {
		return fmt.Errorf("field y in Position: required")
	}
	type Plain Position
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Position(plain)
	return nil
}

type SignalIDType string

type Position struct {
	// X corresponds to the JSON schema field "x".
	X float64 `json:"x" yaml:"x" mapstructure:"x"`

	// Y corresponds to the JSON schema field "y".
	Y float64 `json:"y" yaml:"y" mapstructure:"y"`
}

var enumValues_EntityOutputPriority = []interface{}{
	"right",
	"left",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityOutputPriority) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityOutputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityOutputPriority, v)
	}
	*j = EntityOutputPriority(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityOutputPriority) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityOutputPriority {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityOutputPriority, v)
	}
	*j = EntityOutputPriority(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *ConnectionData) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["entity_id"]; !ok || v == nil {
		return fmt.Errorf("field entity_id in ConnectionData: required")
	}
	type Plain ConnectionData
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = ConnectionData(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectionData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["entity_id"]; !ok || v == nil {
		return fmt.Errorf("field entity_id in ConnectionData: required")
	}
	type Plain ConnectionData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConnectionData(plain)
	return nil
}

type SpeakerParameters struct {
	// AllowPolyphony corresponds to the JSON schema field "allow_polyphony".
	AllowPolyphony *bool `json:"allow_polyphony,omitempty" yaml:"allow_polyphony,omitempty" mapstructure:"allow_polyphony,omitempty"`

	// PlaybackGlobally corresponds to the JSON schema field "playback_globally".
	PlaybackGlobally *bool `json:"playback_globally,omitempty" yaml:"playback_globally,omitempty" mapstructure:"playback_globally,omitempty"`

	// PlaybackVolume corresponds to the JSON schema field "playback_volume".
	PlaybackVolume *float64 `json:"playback_volume,omitempty" yaml:"playback_volume,omitempty" mapstructure:"playback_volume,omitempty"`
}

type LogisticFilter struct {
	// Count corresponds to the JSON schema field "count".
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Index corresponds to the JSON schema field "index".
	Index *int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Color) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["b"]; !ok || v == nil {
		return fmt.Errorf("field b in Color: required")
	}
	if v, ok := raw["g"]; !ok || v == nil {
		return fmt.Errorf("field g in Color: required")
	}
	if v, ok := raw["r"]; !ok || v == nil {
		return fmt.Errorf("field r in Color: required")
	}
	type Plain Color
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Color(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Color) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["b"]; !ok || v == nil {
		return fmt.Errorf("field b in Color: required")
	}
	if v, ok := raw["g"]; !ok || v == nil {
		return fmt.Errorf("field g in Color: required")
	}
	if v, ok := raw["r"]; !ok || v == nil {
		return fmt.Errorf("field r in Color: required")
	}
	type Plain Color
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Color(plain)
	return nil
}

var enumValues_EntityType = []interface{}{
	"input",
	"output",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityType, v)
	}
	*j = EntityType(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *EntityType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EntityType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EntityType, v)
	}
	*j = EntityType(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *ItemFilter) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in ItemFilter: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ItemFilter: required")
	}
	type Plain ItemFilter
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = ItemFilter(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ItemFilter) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in ItemFilter: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ItemFilter: required")
	}
	type Plain ItemFilter
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ItemFilter(plain)
	return nil
}

type SpeakerAlertParameters struct {
	// AlertMessage corresponds to the JSON schema field "alert_message".
	AlertMessage *string `json:"alert_message,omitempty" yaml:"alert_message,omitempty" mapstructure:"alert_message,omitempty"`

	// ShowAlert corresponds to the JSON schema field "show_alert".
	ShowAlert *bool `json:"show_alert,omitempty" yaml:"show_alert,omitempty" mapstructure:"show_alert,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Entity) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["entity_number"]; !ok || v == nil {
		return fmt.Errorf("field entity_number in Entity: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Entity: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Entity: required")
	}
	type Plain Entity
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Entity(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Entity) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["entity_number"]; !ok || v == nil {
		return fmt.Errorf("field entity_number in Entity: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Entity: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Entity: required")
	}
	type Plain Entity
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Entity(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *SignalID) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SignalID: required")
	}
	type Plain SignalID
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = SignalID(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Icon) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in Icon: required")
	}
	if v, ok := raw["signal"]; !ok || v == nil {
		return fmt.Errorf("field signal in Icon: required")
	}
	type Plain Icon
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Icon(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *InfinityFilterMode) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InfinityFilterMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InfinityFilterMode, v)
	}
	*j = InfinityFilterMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignalID) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SignalID: required")
	}
	type Plain SignalID
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SignalID(plain)
	return nil
}

var enumValues_BlueprintItem = []interface{}{
	"blueprint",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlueprintItem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlueprintItem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlueprintItem, v)
	}
	*j = BlueprintItem(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BlueprintItem) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlueprintItem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlueprintItem, v)
	}
	*j = BlueprintItem(v)
	return nil
}

type SignalID struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Type corresponds to the JSON schema field "type".
	Type *SignalIDType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type WaitConditionCompareType string

var enumValues_WaitConditionCompareType = []interface{}{
	"and",
	"or",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WaitConditionCompareType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WaitConditionCompareType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WaitConditionCompareType, v)
	}
	*j = WaitConditionCompareType(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *WaitConditionCompareType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WaitConditionCompareType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WaitConditionCompareType, v)
	}
	*j = WaitConditionCompareType(v)
	return nil
}

const WaitConditionCompareTypeAnd WaitConditionCompareType = "and"
const WaitConditionCompareTypeOr WaitConditionCompareType = "or"

type WaitCondition struct {
	// CompareType corresponds to the JSON schema field "compare_type".
	CompareType *WaitConditionCompareType `json:"compare_type,omitempty" yaml:"compare_type,omitempty" mapstructure:"compare_type,omitempty"`

	// Ticks corresponds to the JSON schema field "ticks".
	Ticks *int `json:"ticks,omitempty" yaml:"ticks,omitempty" mapstructure:"ticks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ScheduleRecord struct {
	// Station corresponds to the JSON schema field "station".
	Station *string `json:"station,omitempty" yaml:"station,omitempty" mapstructure:"station,omitempty"`

	// WaitConditions corresponds to the JSON schema field "wait_conditions".
	WaitConditions []WaitCondition `json:"wait_conditions,omitempty" yaml:"wait_conditions,omitempty" mapstructure:"wait_conditions,omitempty"`
}

type Schedule struct {
	// Locomotives corresponds to the JSON schema field "locomotives".
	Locomotives []int `json:"locomotives,omitempty" yaml:"locomotives,omitempty" mapstructure:"locomotives,omitempty"`

	// Schedule corresponds to the JSON schema field "schedule".
	Schedule []ScheduleRecord `json:"schedule,omitempty" yaml:"schedule,omitempty" mapstructure:"schedule,omitempty"`
}

type Tile struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Position corresponds to the JSON schema field "position".
	Position Position `json:"position" yaml:"position" mapstructure:"position"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Tile: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Tile: required")
	}
	type Plain Tile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Tile(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Tile) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Tile: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in Tile: required")
	}
	type Plain Tile
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Tile(plain)
	return nil
}

const SignalIDTypeVirtual SignalIDType = "virtual"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Blueprint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["entities"]; !ok || v == nil {
		return fmt.Errorf("field entities in Blueprint: required")
	}
	if v, ok := raw["icons"]; !ok || v == nil {
		return fmt.Errorf("field icons in Blueprint: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in Blueprint: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in Blueprint: required")
	}
	type Plain Blueprint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Blueprint(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Blueprint) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["entities"]; !ok || v == nil {
		return fmt.Errorf("field entities in Blueprint: required")
	}
	if v, ok := raw["icons"]; !ok || v == nil {
		return fmt.Errorf("field icons in Blueprint: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in Blueprint: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in Blueprint: required")
	}
	type Plain Blueprint
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = Blueprint(plain)
	return nil
}

const SignalIDTypeFluid SignalIDType = "fluid"

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlueprintSchemaJSONBlueprintBookBlueprintsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blueprint"]; !ok || v == nil {
		return fmt.Errorf("field blueprint in BlueprintSchemaJSONBlueprintBookBlueprintsElem: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in BlueprintSchemaJSONBlueprintBookBlueprintsElem: required")
	}
	type Plain BlueprintSchemaJSONBlueprintBookBlueprintsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BlueprintSchemaJSONBlueprintBookBlueprintsElem(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BlueprintSchemaJSONBlueprintBookBlueprintsElem) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["blueprint"]; !ok || v == nil {
		return fmt.Errorf("field blueprint in BlueprintSchemaJSONBlueprintBookBlueprintsElem: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in BlueprintSchemaJSONBlueprintBookBlueprintsElem: required")
	}
	type Plain BlueprintSchemaJSONBlueprintBookBlueprintsElem
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = BlueprintSchemaJSONBlueprintBookBlueprintsElem(plain)
	return nil
}

const SignalIDTypeItem SignalIDType = "item"

var enumValues_BlueprintSchemaJSONBlueprintBookItem = []interface{}{
	"blueprint-book",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlueprintSchemaJSONBlueprintBookItem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlueprintSchemaJSONBlueprintBookItem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlueprintSchemaJSONBlueprintBookItem, v)
	}
	*j = BlueprintSchemaJSONBlueprintBookItem(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BlueprintSchemaJSONBlueprintBookItem) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlueprintSchemaJSONBlueprintBookItem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlueprintSchemaJSONBlueprintBookItem, v)
	}
	*j = BlueprintSchemaJSONBlueprintBookItem(v)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *SignalIDType) UnmarshalYAML(value *yaml.Node) error {
	var v string
	if err := value.Decode(&v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SignalIDType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SignalIDType, v)
	}
	*j = SignalIDType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignalIDType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SignalIDType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SignalIDType, v)
	}
	*j = SignalIDType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlueprintSchemaJSONBlueprintBook) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blueprints"]; !ok || v == nil {
		return fmt.Errorf("field blueprints in BlueprintSchemaJSONBlueprintBook: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in BlueprintSchemaJSONBlueprintBook: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in BlueprintSchemaJSONBlueprintBook: required")
	}
	type Plain BlueprintSchemaJSONBlueprintBook
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BlueprintSchemaJSONBlueprintBook(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *BlueprintSchemaJSONBlueprintBook) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if v, ok := raw["blueprints"]; !ok || v == nil {
		return fmt.Errorf("field blueprints in BlueprintSchemaJSONBlueprintBook: required")
	}
	if v, ok := raw["item"]; !ok || v == nil {
		return fmt.Errorf("field item in BlueprintSchemaJSONBlueprintBook: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in BlueprintSchemaJSONBlueprintBook: required")
	}
	type Plain BlueprintSchemaJSONBlueprintBook
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = BlueprintSchemaJSONBlueprintBook(plain)
	return nil
}

var enumValues_SignalIDType = []interface{}{
	"item",
	"fluid",
	"virtual",
}
